#!/usr/bin/env coffee

async = require 'async'
optimist = require 'optimist'
posixbre = require 'posixbre'

argv = optimist.posix().boolean('n').argv

script = ''
if not argv.e and not argv.f
  script = argv._.shift()

# If *s* (a string) has the form of a number, coerce it to
# an integer and return it; otherwise, return *s* unchanged.
intify = (s) ->
  x = Number(s)
  if not isNaN(x)
    return 0|x
  return s

# Convert string to address, which is either '$', a number, or a
# RegExp instance.
asAddr = (s) ->
  if s == '$'
    return s
  if s is undefined
    return x
  x = intify s
  if typeof x == 'number'
    return x
  # :todo: handle \cfooc
  if x[0] = '/'
    return RegExp x[1..-2]


parseScript = (s) ->
  label = {}
  cmds = []
  while true
    [s, cmd] = parse1 s
    if s is null
      break
    cmds.push cmd
    if cmd.verb == ':'
      label[cmd.arg] = cmds.length
  return [cmds, label]
# Parse the next command from string *s* returning a pair
# [*s*, *cmd*]
parse1 = (s) ->
  # The REs for addrs are not very right.
  re = ///
    (?:
      ( \d+ | \$ | /(?:[^\\]|\\.)*/ )   # Addr
      (?:,
      ( \d +| \$ | /(?:[^\\]|\\.)*/ )
      )? # Optional Addr2
    )?
    (\s*!)?                         # Optional !
    ([ac]\\|[bDGgHhNPps:])          # Command
  ///g
  m = re.exec s
  if not m
    return [null, null]
  cmd = {}
  cmd.addr1 = asAddr m[1]
  cmd.addr2 = intify m[2]
  cmd.positive = not m[3]
  cmd.verb = m[4][0]
  s = s[re.lastIndex..]
  # Commands that take 'a\' style arguments.
  if cmd.verb in 'ac'
    # Delete through newline.
    s = s.replace /^.*?\n/, ''
    argre = /((?:[^\n\\]|\\[\s\S])*)\n?/g
    m = argre.exec s
    cmd.arg = m[1].replace /\\[\s\S]/g, (x) -> x[1]
    s = s[argre.lastIndex..]
  # Commands that take single line arguments.
  if cmd.verb in ':b'
    argre = /[^\S\n]*(.*)\n?/g
    m = argre.exec s
    cmd.arg = m[1]
    s = s[argre.lastIndex..]
  # s function has a special argument form.
  if cmd.verb == 's'
    argre = ///
      ([^\\\n]) # delimiter, usually /
      ((?:[^\\\n]|\\.)*) # BRE
      \1
      ((?:[^\\\n]|\\.)*) # replacement
      \1
      ([\dgnpw]*) (?:[^\S\n]+(.+))? # flags
    ///g
    m = argre.exec s
    cmd.arg = m[1..5]
    cmd.delimiter = m[1]
    cmd.re = RegExp posixbre.asRegExp(m[2]), 'g'
    cmd.replacement = m[3]
    cmd.flags = m[4]
    digits = cmd.flags.match /\d+/
    if digits
      cmd.nth = +digits
    else
      cmd.nth = +not('g' in cmd.flags)
    cmd.file = m[5]
    s = s[argre.lastIndex..]
    
  return [s, cmd]

[commands,label] = parseScript script

class Sed
  constructor: () ->
    @currentLine = 0
    @pattern = null
    @hold = ''
    @finalLine = false
    # *indirectTo* is used (in eachLine) to determine what to do
    # (what continuation to call) when each line is read from input.
    # (Normally this is beginScript which starts a cycle of script
    # execution, but functions like 'N' can change that).
    @indirectTo = @beginScript

  addrMatch: (addr) ->
    if typeof addr is 'number'
      return @currentLine == addr
    if addr == '$'
      return @finalLine
    if addr instanceof RegExp
      return addr.test @pattern

  finalBuf: ->
    '''Process the final line of input (after the 'end' event
    has been handled).
    '''
    lines = buf.split '\n'
    lines.pop()
    if lines.length
      @finalLine = true
      eachLine lines[0], ->

  beginScript: (line, nextLine) ->
    if @pattern is null
      @pattern = line
    else
      @pattern += '\n' + line
    @currentLine += 1
    # List of delayed functions to call to append stuff after the
    # cycle output (typically 'a' and 'r' verbs).
    appends = []

    endCycle = () =>
      # Pattern space may have been deleted (EG 'c' function).
      if not argv.n and @pattern isnt null
        process.stdout.write @pattern + '\n'
      @pattern = null
      for append in appends
        process.stdout.write append()
      nextLine()

    evalCommand = (cmd, nextCmd) =>
      [execute, endRange] = @evalAddr cmd

      if execute == cmd.positive
        return @evalFunction cmd, endRange, appends, nextCmd, nextLine
      nextCmd()

    @cmdIndex = 0
    script1 = (stop) =>
      # If *stop* is true then we abort the command loop early
      # and begin the next cycle.
      if @cmdIndex >= commands.length or stop
        return endCycle()
      evalCommand commands[@cmdIndex++], script1

    script1()

  evalAddr: (cmd) ->
    endRange = false
    # 0 address.
    if not cmd.addr1 and not cmd.addr2
      execute = true
      endRange = true
    # One address.
    if cmd.addr1 and not cmd.addr2
      execute = @addrMatch cmd.addr1
      endRange = true
    # Two address.
    if cmd.addr1 and cmd.addr2
      if not cmd.flipped
        execute = false
        if @addrMatch cmd.addr1
          execute = true
          cmd.flipped = true
          # There is a bit of a special case for numeric 2nd addrs
          if typeof cmd.addr2 == 'number'
            if cmd.addr2 <= @currentLine
              cmd.flipped = false
              endRange = true
      else
        execute = true
        if @addrMatch cmd.addr2
          cmd.flipped = false
          endRange = true
    return [execute, endRange]

  evalFunction: (cmd, endRange, appends, nextCmd, nextLine) ->
    if 'a' == cmd.verb
      appends.push -> (cmd.arg + '\n')
    if 'b' == cmd.verb
      index = @label[cmd.arg]
      if index?
        @cmdIndex = index
      else
        console.warn "Branch label [[#{cmd.arg}]] is missing."
        @cmdIndex = Infinity
    if 'c' == cmd.verb
      @pattern = null
      if endRange
        process.stdout.write cmd.arg + '\n'
      return nextCmd 'cycle'
    if 'D' == cmd.verb
      if '\n' in @pattern
        @pattern = @pattern.replace /^.*?\n/, ''
      else
        @pattern = null
      return nextCmd 'cycle'
    if 'G' == cmd.verb
      @pattern += '\n' + @hold
    if 'g' == cmd.verb
      @pattern = @hold
    if 'H' == cmd.verb
      @hold += '\n' + @pattern
    if 'h' == cmd.verb
      @hold = @pattern
    if 'N' == cmd.verb
      @indirectTo = (line) =>
        @pattern += '\n' + line
        @currentLine += 1
        @indirectTo = @beginScript
        nextCmd()
      return nextLine()
    if 'P' == cmd.verb
      if '\n' in @pattern
        process.stdout.write @pattern[..@pattern.indexOf '\n']
      else
        process.stdout.write @pattern + '\n'
    if 'p' == cmd.verb
      process.stdout.write @pattern + '\n'
    if 's' == cmd.verb
      cmd.re.lastIndex = 0
      matchCount = 0
      substituted = false
      result = []
      lastIndex = 0
      while true
        m = cmd.re.exec @pattern
        if not m
          break
        matchCount += 1
        if 'g' in cmd.flags or cmd.nth == matchCount
          substituted = @substituted = true
          repl = cmd.replacement.replace /\\.|[^\\]/g, (particle) ->
            if particle == '&'
              return m[0]
            if particle[0] != '\\'
              return particle
            # particle[0] is '\\'
            if particle[1] in '&\\'
              return particle[1]
            if /[1-9]/.test particle[1]
              return m[particle[1]]
          result = result.concat [
            @pattern.slice(lastIndex, m.index)
            repl
          ]
          lastIndex = cmd.re.lastIndex
          if m.index == cmd.re.lastIndex
            # Zero-width match.
            cmd.re.lastIndex += 1
        if cmd.nth and matchCount >= cmd.nth
          break
      if substituted
        result.push @pattern.slice lastIndex
        @pattern = result.join ''
        if 'p' in cmd.flags
          process.stdout.write @pattern + '\n'

    nextCmd()

sed = new Sed
sed.label = label

eachLine = (line, cb) ->
  return sed.indirectTo line, cb

buf = ''
processing = false
ended = false
process.stdin.on 'data', (data) ->
  process.stdin.pause()
  processing = true
  buf += data
  lines = buf.split '\n'
  buf = lines.pop()
  if buf == '' and lines.length
    # Retain last line of data, as it might be the final
    # line of input.
    buf = lines.pop() + '\n'
  async.eachSeries lines, eachLine, () ->
    processing = false
    process.stdin.resume()
  if ended
    # Must have been set during the async call.
    sed.finalBuf()

process.stdin.on 'end', () ->
  ended = true 
  if not processing
    sed.finalBuf()
